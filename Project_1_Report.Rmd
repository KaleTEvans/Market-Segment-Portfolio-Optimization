---
title: "Project 1"
author: "Kale Evans"
date: "2024-05-06"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
#############################
# Project 1
#############################

####################################################################
# Using code below from provided solution to ensure accuracy of data
####################################################################

# clear environment
rm(list = ls())

# libraries and packages
library(quantmod)
library(tidyverse)
library(moments)
library(CVXR)
library(PerformanceAnalytics)
library(knitr)
#library(glpkAPI)

# Cache data once computed correctly
if (!dir.exists("cache")) {
  dir.create("cache")
}
cached_file <- "cache/cached_project1report_data.rda"
if ( file.exists(cached_file) ) {
  load(cached_file)
} else {

# Get data
from = as.Date("01/01/2005", format = "%m/%d/%Y")
to = as.Date("04/01/2024", format = "%m/%d/%Y")

yahooSymbols_df = data.frame(symbols = c("IWB", "IWM",
                                         "EFA", "EEM",
                                         "VNQ", "LQD","SHY"),
                             label = c("Large Cap US","Small Cap US",
                                       "Dev. Mkts", "Emer Mkts",
                                       "Global REIT", "Corp. Bonds","Short Tsy"))


invisible(getSymbols(yahooSymbols_df$symbols, src = "yahoo", from = from , to = to))

yahooReturnData_xts <- do.call("cbind",lapply(yahooSymbols_df$symbols, FUN = function(symb){
  temp <- eval(parse(text = symb))
  #  colnames(temp) <-  paste0(symb,c(".Open",".High",".Low",".Close",".Volume",".Adjusted"))
  temp <- temp[,6]
  #  colnames(temp) <- c(paste0(symb,""))
}))
colnames(yahooReturnData_xts) <- gsub(".Adjusted","",colnames(yahooReturnData_xts))

temp <- log(yahooReturnData_xts/stats::lag(yahooReturnData_xts))

temp <- temp[-1,]

financialDataReturns_xts <- temp

dim(financialDataReturns_xts)

# Aggregate returns to 5, 21, 62 and 252 day intervals

return_list = list()
return_list_df = list()
for(numDays in c(1, 5, 21, 62, 252)){
  return_xts = rollapply(financialDataReturns_xts,
                         width = numDays, 
                         sum,
                         by = numDays,
                         align = "right")
  item_name =  paste0("days_",numDays)
  # add non-NA rows of returns_xts to list
  valid_returns_xts = return_xts[rowSums(is.na(return_xts)) == 0,]
  return_list[[item_name]] = valid_returns_xts
  
  # Convert to data frame and set row names as Date
  temp_df <- as.data.frame(valid_returns_xts)
  rownames(temp_df) <- index(valid_returns_xts)  # Setting index as row names
  return_list_df[[item_name]] = temp_df
}

# check number of observations for each time period length
lapply(return_list, dim)

######################################################################
# End copied code
######################################################################

# Will be using the ROI Solver Package
# Package had great documentation on setting objectives / constraints

if (!require("ROI")) install.packages("ROI"); library("ROI")
if (!require("ROI.plugin.glpk")) install.packages("ROI.plugin.glpk"); library("ROI.plugin.glpk")
if (!require("ROI.plugin.quadprog")) install.packages("ROI.plugin.quadprog"); library("ROI.plugin.quadprog")
if (!require("ROI.plugin.alabama")) install.packages("ROI.plugin.alabama"); library("ROI.plugin.alabama")

###########################
# Min Variance Objective
###########################
markowitz_objective <- function(r_mat) {
  objective <- Q_objective(Q = 2 * cov(r_mat), 
                           L = rep(0, NCOL(r_mat)))
  list(objective = objective)
}

###########################
# Min MAD Objective
###########################
mad_objective <- function(r_mat){
  x.names <- colnames(r_mat)
  N <- NCOL(r_mat)
  S <- nrow(r_mat)
  mu <- colMeans(r_mat)
  Amat <-  cbind(sweep(as.matrix(r_mat), 2,  mu), - diag(S), diag(S))
  var.names <- c(x.names, 
                 paste0("y_mad_aux", seq_len(S)),
                 paste0("z_mad_aux", seq_len(S)))
  
  constraint <-  L_constraint(L = Amat, dir = rep("==", S), 
                              rhs = rep(0, S), 
                              names = var.names)
  
  objective <- L_objective(L = c(rep(0, N), rep(1/S, 2 * S)))
  
  list(objective = objective, constraint = constraint)
}

#############################
# Min CVAR Objective
#############################

cvar_objective <- function(r_mat, alpha, probs = NULL) {
  x.names <- colnames(r_mat)
  N <- NCOL(r_mat)
  S <- NROW(r_mat)
  mu <- colMeans(r_mat)
  if (is.null(probs)) probs <- rep(1/S, S)
  if (alpha < 0.5) alpha <- 1 - alpha
  
  Amat <- cbind(as.matrix(r_mat),  diag(S), 1)
  var.names <- c(x.names, paste0("z_cvar_aux", seq_len(S)), "gamma")
  
  ## set bounds for gamma (-Inf, Inf) 
  bnds <- ROI::V_bound(li = c(N + S + 1), lb = c( -Inf),
                       ui = c(N + S + 1), ub = c(  Inf))
  
  constraint <- L_constraint(L = Amat, dir = rep(">=", S), 
                             rhs = rep(0, S), 
                             names = var.names)
  
  objective <- L_objective(c(rep(0, N), probs/(1 - alpha), 1))
  
  list(objective = objective, constraint = constraint, bounds = bnds)
}

############################
# Full Investment Constraint
############################
budget_constraint <- function(r_mat, dir = "==", rhs = 1) {
  x.names <- colnames(r_mat)
  L_constraint(L = rep(1, NCOL(r_mat)), 
               dir = dir,  rhs = rhs, names = x.names)
}

#############################
# Target Return Constraint
#############################
reward_constraint <- function(r_mat, dir = ">=", rhs = target) {
  x.names <- colnames(r_mat)
  L_constraint(L = colMeans(r_mat), dir = dir,  
               rhs = rhs, names = x.names)
}

#################################################
# Function for Computing MAD, Min Var, and CVAR
#################################################

compute_risk_measures <- function(returns, target) {
  
  ## Min Variance
  lp  <- OP(objective  =  markowitz_objective(returns)$objective,
            constraints = rbind(budget_constraint(returns),
                                reward_constraint(returns, rhs = target)))
  (sol <- ROI_solve(lp, solver = "quadprog"))
  min_var_solution <- round(solution(sol), 4)
  
  ## MAD
  lp  <- OP(objective  =  mad_objective(returns)$objective,
            constraints = rbind(mad_objective(returns)$constraint,
                                budget_constraint(returns),
                                reward_constraint(returns, rhs = target),
                                use.names = TRUE))
  (sol <- ROI_solve(lp, solver = "glpk"))
  mad_solution <- round(solution(sol)[seq_len(NCOL(returns))], 4)
  
  ## CVAR
  tmp <- cvar_objective(returns, alpha = 0.90)
  lp  <- OP(objective  =  tmp$objective,
            constraints = rbind(tmp$constraint,
                                budget_constraint(returns),
                                reward_constraint(returns, rhs = target),
                                use.names = TRUE),
            bounds = tmp$bounds)
  (sol <- ROI_solve(lp, solver = "glpk"))
  cvar_solution <- round(solution(sol)[seq_len(NCOL(returns))], 4)
  
  return(cbind(min_var_solution, mad_solution, cvar_solution))
}

#############################
# Compute Portfolio Weights
#############################

daily_multiplier <- 1/252
weekly_multiplier <- 5/252
monthly_multiplier <- 21/252
quarterly_multiplier <- 62/252
annual_multiplier <- 1

daily_2pct_target <- compute_risk_measures(return_list_df$days_1, (0.02 * daily_multiplier))
daily_4pct_target <- compute_risk_measures(return_list_df$days_1, (0.04 * daily_multiplier))
daily_6pct_target <- compute_risk_measures(return_list_df$days_1, (0.06 * daily_multiplier))

weekly_2pct_target <- compute_risk_measures(return_list_df$days_5, (0.02 * weekly_multiplier))
weekly_4pct_target <- compute_risk_measures(return_list_df$days_5, (0.04 * weekly_multiplier))
weekly_6pct_target <- compute_risk_measures(return_list_df$days_5, (0.06 * weekly_multiplier))

monthly_2pct_target <- compute_risk_measures(return_list_df$days_21, (0.02 * monthly_multiplier))
monthly_4pct_target <- compute_risk_measures(return_list_df$days_21, (0.04 * monthly_multiplier))
monthly_6pct_target <- compute_risk_measures(return_list_df$days_21, (0.06 * monthly_multiplier))

quarterly_2pct_target <- compute_risk_measures(return_list_df$days_62, (0.02 * quarterly_multiplier))
quarterly_4pct_target <- compute_risk_measures(return_list_df$days_62, (0.04 * quarterly_multiplier))
quarterly_6pct_target <- compute_risk_measures(return_list_df$days_62, (0.06 * quarterly_multiplier))

annual_2pct_target <- compute_risk_measures(return_list_df$days_252, (0.02 * annual_multiplier))
annual_4pct_target <- compute_risk_measures(return_list_df$days_252, (0.04 * annual_multiplier))
annual_6pct_target <- compute_risk_measures(return_list_df$days_252, (0.06 * annual_multiplier))

# Save cached variables
save(return_list, return_list_df, 
     daily_2pct_target, daily_4pct_target, daily_6pct_target,
     weekly_2pct_target, weekly_4pct_target, weekly_6pct_target,
     monthly_2pct_target, monthly_4pct_target, monthly_6pct_target,
     quarterly_2pct_target, quarterly_4pct_target, quarterly_6pct_target,
     annual_2pct_target, annual_4pct_target, annual_6pct_target, file = cached_file)

}

convert_to_df <- function(target_matrix) {
  df <- as.data.frame(target_matrix)
  colnames(df) <- c("Min Variance", "Min MAD", "Min CVaR")
  return(df)
}

target_list <- list(
  daily_2pct = daily_2pct_target,
  daily_4pct = daily_4pct_target,
  daily_6pct = daily_6pct_target,
  weekly_2pct = weekly_2pct_target,
  weekly_4pct = weekly_4pct_target,
  weekly_6pct = weekly_6pct_target,
  monthly_2pct = monthly_2pct_target,
  monthly_4pct = monthly_4pct_target,
  monthly_6pct = monthly_6pct_target,
  quarterly_2pct = quarterly_2pct_target,
  quarterly_4pct = quarterly_4pct_target,
  quarterly_6pct = quarterly_6pct_target,
  annual_2pct = annual_2pct_target,
  annual_4pct = annual_4pct_target,
  annual_6pct = annual_6pct_target
)

# Convert each portfolio to a data frame with uniform column names
portfolio_weight_list <- lapply(target_list, convert_to_df)

options(scipen = 999)

# For some reason I was getting errors when attempting to calculate CVaR in get_portfolio_statistics
# The safe_cvar_calc() function will ensure the calculation is performed correctly
safe_cvar_calc <- function(returns, var_value) {
  # Ensure var_value is numeric and not an array/matrix
  var_value <- as.numeric(var_value)
  
  # Subset returns below the negative VaR
  sub_returns <- returns[returns <= -var_value]
  
  # Calculate mean if subset is not empty
  if (length(sub_returns) > 0) {
    return(-mean(sub_returns))
  } else {
    return(NA)
  }
}

###################################
# Compute Portfolio Statistics
###################################

get_portfolio_statistics <- function(weights, returns) {
  min_var_weights <- matrix(weights[,1], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  mad_weights <- matrix(weights[,2], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  cvar_weights <- matrix(weights[,3], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  
  min_var_returns <- min_var_weights %*% t(returns)
  mad_returns <- mad_weights %*% t(returns)
  cvar_returns <- cvar_weights %*% t(returns)
  
  min_var_returns <- as.vector(min_var_returns)
  mad_returns <- as.vector(mad_returns)
  cvar_returns <- as.vector(cvar_returns)
  
  min_var_mean <- mean(min_var_returns)
  mad_mean <- mean(mad_returns)
  cvar_mean <- mean(cvar_returns)
  
  min_var_sd <- sd(min_var_returns)
  mad_sd <- sd(mad_returns)
  cvar_sd <- sd(cvar_returns)
  
  min_var_mad <- MeanAbsoluteDeviation(min_var_returns)
  mad_mad <- MeanAbsoluteDeviation(mad_returns)
  cvar_mad <- MeanAbsoluteDeviation(cvar_returns)
  
  min_var_var <- quantile(min_var_returns, 0.10) * -1
  mad_var <- quantile(mad_returns, 0.10) * -1
  cvar_var <- quantile(cvar_returns, 0.10) * -1

  min_var_cvar <- safe_cvar_calc(min_var_returns, min_var_var)
  mad_cvar <- safe_cvar_calc(mad_returns, mad_var)
  cvar_cvar <- safe_cvar_calc(cvar_returns, cvar_var)
  
  stats_df = data.frame(
    "Min Variance" = c(min_var_mean, min_var_sd, min_var_mad, min_var_var, min_var_cvar) * 100,
    "Min MAD" = c(mad_mean, mad_sd, mad_mad, mad_var, mad_cvar) * 100,
    "Min CVaR" = c(cvar_mean, cvar_sd, cvar_mad, cvar_var, cvar_cvar) * 100
  )
  
  row.names(stats_df) <- c("Expected Return", "Standard Deviation", "Mean Absolute Deviation", "Value-at-Risk", "Conditional Value-at-Risk")
  return(stats_df)
}

portfolio_stats_list <- list(
  stats_2pct_daily = get_portfolio_statistics(daily_2pct_target, return_list$days_1),
  stats_4pct_daily = get_portfolio_statistics(daily_4pct_target, return_list$days_1),
  stats_6pct_daily = get_portfolio_statistics(daily_6pct_target, return_list$days_1),
  
  stats_2pct_weekly = get_portfolio_statistics(weekly_2pct_target, return_list$days_5),
  stats_4pct_weekly = get_portfolio_statistics(weekly_4pct_target, return_list$days_5),
  stats_6pct_weekly = get_portfolio_statistics(weekly_6pct_target, return_list$days_5),
  
  stats_2pct_monthly = get_portfolio_statistics(monthly_2pct_target, return_list$days_21),
  stats_4pct_monthly =  get_portfolio_statistics(monthly_4pct_target, return_list$days_21),
  stats_6pct_monthly = get_portfolio_statistics(monthly_6pct_target, return_list$days_21),
  
  stats_2pct_quarterly = get_portfolio_statistics(quarterly_2pct_target, return_list$days_62),
  stats_4pct_quarterly = get_portfolio_statistics(quarterly_4pct_target, return_list$days_62),
  stats_6pct_quarterly = get_portfolio_statistics(quarterly_6pct_target, return_list$days_62),
  
  stats_2pct_annual = get_portfolio_statistics(annual_2pct_target, return_list$days_252),
  stats_4pct_annual = get_portfolio_statistics(annual_4pct_target, return_list$days_252),
  stats_6pct_annual = get_portfolio_statistics(annual_6pct_target, return_list$days_252)
)
```

The following report details various portfolio allocations based around 7 ETFs tracking different market segments, displayed below:

```{r echo=FALSE, message=FALSE}

market_data <- data.frame(
  "Market_Segment" = c("Large Cap U.S. Stocks", "Small Cap U.S. Stocks", 
                       "Dev. Mkts. nonUS Stocks", "Emerging Mkt Stock", 
                       "Global REIT", "Corp. Bonds", "Short Treasury"),
  "ETF" = c("IWB", "IWM", "EFA", "EEM", "VNQ", "LQD", "SHY")
)

kable(market_data, align = c('l','c'), col.names = gsub("_", " ", names(market_data)))
```

The analysis began with constructing a portfolio based on the following objectives and constraints:

* Full Portfolio Investment
* Non-Negative Allocations (Long-Only)
* Time Period Constraint (January 1, 2005 to April 1, 2024)

* Minimizing the following risk measures:   
  * Variance
  * Mean Absolute Deviation (MAD)
  * Conditional Value at Risk at 90% Confidence $(CVaR_{90})$
  
* Analysis over multiple time frames:
  * Daily Return Data (1 Day)
  * Weekly Return Data (5 Day)
  * Monthly Return Data (21 Day)
  * Quarterly Return Data (62 Day)
  * Annual Return Data (252 Day)
  
* Allocation based on multiple target returns:
  * 2% (Annualized)
  * 4% (Annualized)
  * 6% (Annualized)

In total, the report will contain 45 different portfolio allocations (3 target returns x 5 time periodicities x 3 risk measures)

\newpage

For each of these allocations, statistical analysis was performed to obtain the following data points:

* Expected Return
* Standard Deviation
* Mean Absolute Deviation (MAD)
* Value at Risk at 90% Confidence $(VaR_{90})$
* Conditional Value at Risk at 90% Confidence $(CVaR_{90})$

The report is structured in the following manner: 

* **Part 1**: Detailed view of collected data. Starting from the smallest time frame, the portfolio weight for each risk measure will be shown first, followed by the calculated statistical values.
  * **An Important Note**: All statistical values are displayed as percentages, e.g. (decimal value x 100)
* **Part 2**: Empirical analysis and comparison of models.
* **Part 3**: Conclusions and analysis of predictions.

\newpage

## Part 1

### Daily Time Period

```{r echo=FALSE}
kable(portfolio_weight_list$daily_2pct, caption = "Optimal Portfolio Weights (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_2pct_daily, caption = "Portfolio Statistics (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_weight_list$daily_4pct, caption = "Optimal Portfolio Weights (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_4pct_daily, caption = "Portfolio Statistics (4% Annual Target)")
```

\newpage

```{r echo=FALSE}
kable(portfolio_weight_list$daily_6pct, caption = "Optimal Portfolio Weights (6% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_6pct_daily, caption = "Portfolio Statistics (6% Annual Target)")
```

### Weekly Time Period

```{r echo=FALSE}
kable(portfolio_weight_list$weekly_2pct, caption = "Optimal Portfolio Weights (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_2pct_weekly, caption = "Portfolio Statistics (2% Annual Target)")
```

\newpage

```{r echo=FALSE}
kable(portfolio_weight_list$weekly_4pct, caption = "Optimal Portfolio Weights (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_4pct_weekly, caption = "Portfolio Statistics (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_weight_list$weekly_6pct, caption = "Optimal Portfolio Weights (6% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_6pct_weekly, caption = "Portfolio Statistics (6% Annual Target)")
```

\newpage

### Monthly Time Period

```{r echo=FALSE}
kable(portfolio_weight_list$monthly_2pct, caption = "Optimal Portfolio Weights (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_2pct_monthly, caption = "Portfolio Statistics (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_weight_list$monthly_4pct, caption = "Optimal Portfolio Weights (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_4pct_monthly, caption = "Portfolio Statistics (4% Annual Target)")
```

\newpage

```{r echo=FALSE}
kable(portfolio_weight_list$monthly_6pct, caption = "Optimal Portfolio Weights (6% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_6pct_monthly, caption = "Portfolio Statistics (6% Annual Target)")
```

### Quarterly Time Period

```{r echo=FALSE}
kable(portfolio_weight_list$quarterly_2pct, caption = "Optimal Portfolio Weights (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_2pct_quarterly, caption = "Portfolio Statistics (2% Annual Target)")
```

\newpage

```{r echo=FALSE}
kable(portfolio_weight_list$quarterly_4pct, caption = "Optimal Portfolio Weights (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_4pct_quarterly, caption = "Portfolio Statistics (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_weight_list$quarterly_6pct, caption = "Optimal Portfolio Weights (6% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_6pct_quarterly, caption = "Portfolio Statistics (6% Annual Target)")
```

\newpage

### Annual Time Period

```{r echo=FALSE}
kable(portfolio_weight_list$annual_2pct, caption = "Optimal Portfolio Weights (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_2pct_annual, caption = "Portfolio Statistics (2% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_weight_list$annual_4pct, caption = "Optimal Portfolio Weights (4% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_4pct_annual, caption = "Portfolio Statistics (4% Annual Target)")
```

\newpage

```{r echo=FALSE}
kable(portfolio_weight_list$annual_6pct, caption = "Optimal Portfolio Weights (6% Annual Target)")
```

```{r echo=FALSE}
kable(portfolio_stats_list$stats_6pct_annual, caption = "Portfolio Statistics (6% Annual Target)")
```

\newpage

## Part 2

The following analysis will be broken up by each time periodicity. While not attached, some aspects will refer to analyses made in Part 1 of the project, so be sure to have a copy of the data for reference. Overall conclusions will be in Part 3 of this report.

### Analysis of Daily Time Period Models

```{r echo=FALSE}
targets <- data.frame(
  "Annual_Target_Percent" = c("2%", "4%", "6%"),
  "Daily_Target_Percent_Value" = c(((1/252) * 0.02) * 100, ((1/252) * 0.04) * 100, ((1/252) * 0.06) * 100)
)

kable(targets, align = c('c','c'), col.names = gsub("_", " ", names(targets)))
```

A close glance at the weights for each of the 2,4, and 6% annual target portfolios will show that allocations are essentially the same. They are exactly the same for the 2% target, and vary slightly across the different risk measures for the 4 and 6% targets. Analyzing each target individually can provide valuable information behind these results.

Taking a look at the 2% target, let's first consider how small of a target this is to reach in the financial markets. This is currently below the 2024 risk-free rate, which has held steady over 4% for the last several months. If 2% is a hard target, one would actually need to seek out risk, rather than just allocating the entire portfolio to short treasuries (SHY) this year (**Note: See annual analysis about negative VaR**). However, there were some periods of time within the analysis time period where the risk-free rate was below 2%. In the Part 1 report, it was determined that SHY had the lowest risk out of all the assets, but the expected return of 0.00067% for all three 2% portfolio models falls just short of the target of 0.000794%. This is why we see the small allocation to IWB. The simplest way to explain why IWB was chosen as the remaining portfolio element to reach the 2% target is because this is the ETF with the highest average return by far, with the third lowest standard deviation out of all the asset classes. One might ask why we don't consider LQD as the second component to reach our target, as it has the second lowest standard deviation / 10th percentile quantile.  Aside from further math going into the specifics, one might assume that leaving a small allocation to an asset with high expected returns, such as large cap stocks, likely carries less risk on average than requiring a significant allocation to corporate bonds. 

Now, as the return target increases to 4 and 6%, the optimal portfolios all allocate more weight to LQD. As the target increases from 4 to 6% we see a significant increase in weighting for both IWB and LQD while SHY decreases significantly. First, we see that the minimum variance portfolio carries the highest weight of SHY compared to the other risk measures, especially in the portfolios with the 6% target. As mentioned previously, now that we have higher return targets to hit, the allocation dynamic becomes a little more complex. The portfolios can be seen allocating higher weights to the riskier large cap stocks, and to counter this increase in risk across all risk measures, the portfolios see increased allocations to corporate bonds, where risk levels lie somewhere in between IWB and SHY (See Part 1 Data). Eventually, with the 6% target, the allocation to LQD begins to overtake that of SHY, as would be expected due to higher target requirements translating to higher risk requirements. 

Now, we actually start to see differences in outcomes when seeking to minimize risk measures that monitor the variability of the data (MAD and Variance) compared to risk measures that monitor losses after a certain threshold (CVaR). From left to right of both of the model portfolio statistics tables, we have Variance, followed by MAD, and finally CVaR. We can see that standard deviation increases from left to right, while VaR and CVaR decrease. The reasoning behind these differences is somewhat obvious, as we would expect the minimum CVaR portfolio to have the lowest CVaR. Due to variance being squared, compared to MAD being an absolute value of deviations from the mean, values that increasingly deviate from the mean have an increased impact on variance, and therefore the minimized variance portfolio might overcompensate when seeking to minimize deviations from the mean in comparison to MAD, which would explain the lower standard deviation.

Going forward, many of the considerations for the daily data remain the same across higher timeframes. To avoid repetition, I will only seek to point out new variations in the outcome that are specific to certain timeframes. 

### Analysis of Weekly Time Period Models

```{r echo=FALSE}
targets <- data.frame(
  "Annual_Target_Percent" = c("2%", "4%", "6%"),
  "Daily_Target_Percent_Value" = c(((5/252) * 0.02) * 100, ((5/252) * 0.04) * 100, ((5/252) * 0.06) * 100)
)

kable(targets, align = c('c','c'), col.names = gsub("_", " ", names(targets)))
```

The results of the optimized portfolios for the weekly time frame are more or less the same as the results from the daily portfolios. The increase in periodicity is likely still too small to allow for any noticeable differences.

### Analysis of Monthly Time Period Models

```{r echo=FALSE}
targets <- data.frame(
  "Annual_Target_Percent" = c("2%", "4%", "6%"),
  "Daily_Target_Percent_Value" = c(((21/252) * 0.02) * 100, ((21/252) * 0.04) * 100, ((21/252) * 0.06) * 100)
)

kable(targets, align = c('c','c'), col.names = gsub("_", " ", names(targets)))
```

Surprisingly, the portfolio allocations based on monthly returns have yet to show any differences from the previous time frames.

### Analysis of Quarterly Time Period Models

```{r echo=FALSE}
targets <- data.frame(
  "Annual_Target_Percent" = c("2%", "4%", "6%"),
  "Daily_Target_Percent_Value" = c(((62/252) * 0.02) * 100, ((62/252) * 0.04) * 100, ((62/252) * 0.06) * 100)
)

kable(targets, align = c('c','c'), col.names = gsub("_", " ", names(targets)))
```

There are a few discrepancies in the portfolios optimized around quarterly returns that are of interest in comparison to the smaller time frames. First, the 2% target minimum variance portfolio introduces a small allocation to IWM. My first reaction is that this may be due to a calculation error, or perhaps some sporadic data. The standard deviation of the quarterly returns for IWM is still higher than that of IWB and the expected return is still smaller. But taking a further look at the project 1 data, one might notice that the relative differences in standard deviation between IWM and IWB have become much smaller compared to those of smaller time frames, while the negative skew of IWB has increased alongside an increase in kurtosis, both with absolute values larger than those of IWM. As mentioned previously, with the variance being more sensitive to larger deviations from the mean, if IWB is starting to see larger deviations from the mean at the tails of the distribution, this might explain the small allocation to IWM, as the minimum variance portfolio seeks to minimize the risk of larger deviations from the mean that occur in IWB. 

Another interesting observation is that SHY has 0 weight in the minimum CVaR portfolio with a 6% target return. It's also interesting to note that the VaR is significantly higher than the minimum variance and minimum MAD portfolios, however the CVaR is still lower than the other two risk measure portfolios. Without looking at the data, the best explanation for this discrepancy would be that SHY has had periods of several large quarterly losses that extend those of corporate bonds. These losses may be insignificant when averaged over the entire time period, which would explain why the min variance and min MAD portfolios still allocate some weight to SHY. Considering that in the time period under analysis, the financial markets have undergone two significant events where rapid decreases in interest rates have occurred (the 2008 financial crisis and the 2020 covid lockdowns), these events may explain the outcome, but further analysis is likely needed. 

### Analysis of Annual Time Period Models

```{r echo=FALSE}
targets <- data.frame(
  "Annual_Target_Percent" = c("2%", "4%", "6%"),
  "Daily_Target_Percent_Value" = c((0.02) * 100, (0.04) * 100, (0.06) * 100)
)

kable(targets, align = c('c','c'), col.names = gsub("_", " ", names(targets)))
```

Lastly, the annual data shows some more interesting discrepancies. Recall that I noted that a 2% annual target would likely involve a requirement of risk-seeking investments. We see in the 2% portfolios, all 3 risk measures allocate a small amount to VNQ. In comparison to IWB, VNQ, which represents global REITs, has a lower expected return, and higher standard deviation, e.g. high risk / low reward. This directly supports the previously stated risk-taking theory. We also see an allocation to IWM over IWB in the minimum variance portfolio for the 2% target. However, looking at the data from Project 1, the standard deviation values for the annual IWB and IWM data are almost the same. The best explanation behind this occurence is that IWM experienced less extreme deviations from the mean at the tail end of the distribution.

Next, this is where we see negative values for VaR across all three risk measures for the 2% target portfolios. A negative value at risk would indicate that the portfolio has a high probability of making profit at the given confidence level, which in our case is 90%. This is due to reasons stated earlier, that a 2% annual target is essentially risk free. 

Wrapping up the analysis of the statistical outcomes of the various portfolios, we see again that the minimum CVaR portfolio with a 6% target does not allocate any weight to SHY. This can be explained by the same logic previously stated for the quarterly return data.

## Part 3

### Part 1 Predictions Vs Results

First, a quick summary of the predictions I made from the data obtained in Part 1 of the analysis. 

* IWB will have the highest weighting in the portfolio across all risk measures, and especially have the highest weighting out of all of the stock comprised ETFs across all risk measures, and that this would be the most favorable risk asset when attempting to reach the target return. 

* IWM would have a higher weighting relative to IWB in a select number of portfolios due to the fact that IWM had higher returns in the top 90th percentile. 

* EFA and EEM would be the least favorable investments, with low average returns and high standard deviation

* VNQ would also be unfavorable to most portfolios, and would have a high CVaR value in higher time frames

* LQD would become more favorable in higher time frames

* SHY is the lowest risk asset and will likely contain some weight in most portfolios, and will likely have higher weighting in minimum MAD portfolios

Starting with IWM, I was incorrect that this would have the highest weighting for most portfolios. I believe the mistake here was that I was thinking a little to ambitiously regarding the target returns, as 2,4, and 6% are all low returns relative to what is typically expected from the market. However, i was correct for the most part that it would be the most favorable stock comprised ETF aside from a few anomalies. My prediction around IWM was somewhat correct, as it did have higher weighting in one portfolio, although likely not due to the reasoning that it had higher 90th percentile returns. With regards to EFA, EEM, and VNQ, my assumptions were mostly correct, aside from the anomaly with the 2% return target for the annual return data. My prediction with LQD was correct, as it did indeed have higher weighting in higher time frames, but only for the 4 and 6% targets. And lastly, SHY did indeed have weighting in most portfolios, aside from the exceptions of minimuim CVaR portfolios with a 6% target at higher time frames. 

### Additional Insights

What I found to be most intriguing following the data analysis was that in relative terms, portfolio allocations did not differ very much across the different time frames. I had initially assumed that certain assets in smaller time frames would have a larger affect on risk measures, and therefore cause varying portfolio allocations, but this was not the case. This supports the reasoning for most financial analyses being conducted with annual data, and that focusing on day to day data tends to just provide more noise rather than signal. This was a great exercise in verifying the reasoning behind the methodology taught by many financial professionals. 

\newpage

### R Code Appendix

```{r eval=FALSE}
#############################
# Project 1
#############################

####################################################################
# Using code below from provided solution to ensure accuracy of data
####################################################################

# clear environment
rm(list = ls())

# libraries and packages
library(quantmod)
library(tidyverse)
library(moments)
library(CVXR)
library(PerformanceAnalytics)
library(knitr)
#library(glpkAPI)

# Cache data once computed correctly
if (!dir.exists("cache")) {
  dir.create("cache")
}
cached_file <- "cache/cached_project1report_data.rda"
if ( file.exists(cached_file) ) {
  load(cached_file)
} else {

# Get data
from = as.Date("01/01/2005", format = "%m/%d/%Y")
to = as.Date("04/01/2024", format = "%m/%d/%Y")

yahooSymbols_df = data.frame(symbols = c("IWB", "IWM",
                                         "EFA", "EEM",
                                         "VNQ", "LQD","SHY"),
                             label = c("Large Cap US","Small Cap US",
                                       "Dev. Mkts", "Emer Mkts",
                                       "Global REIT", "Corp. Bonds","Short Tsy"))


invisible(getSymbols(yahooSymbols_df$symbols, src = "yahoo", from = from , to = to))

yahooReturnData_xts <- do.call("cbind",lapply(yahooSymbols_df$symbols, FUN = function(symb){
  temp <- eval(parse(text = symb))
  #  colnames(temp) <-  paste0(symb,c(".Open",".High",".Low",".Close",".Volume",".Adjusted"))
  temp <- temp[,6]
  #  colnames(temp) <- c(paste0(symb,""))
}))
colnames(yahooReturnData_xts) <- gsub(".Adjusted","",colnames(yahooReturnData_xts))

temp <- log(yahooReturnData_xts/stats::lag(yahooReturnData_xts))

temp <- temp[-1,]

financialDataReturns_xts <- temp

dim(financialDataReturns_xts)

# Aggregate returns to 5, 21, 62 and 252 day intervals

return_list = list()
return_list_df = list()
for(numDays in c(1, 5, 21, 62, 252)){
  return_xts = rollapply(financialDataReturns_xts,
                         width = numDays, 
                         sum,
                         by = numDays,
                         align = "right")
  item_name =  paste0("days_",numDays)
  # add non-NA rows of returns_xts to list
  valid_returns_xts = return_xts[rowSums(is.na(return_xts)) == 0,]
  return_list[[item_name]] = valid_returns_xts
  
  # Convert to data frame and set row names as Date
  temp_df <- as.data.frame(valid_returns_xts)
  rownames(temp_df) <- index(valid_returns_xts)  # Setting index as row names
  return_list_df[[item_name]] = temp_df
}

# check number of observations for each time period length
lapply(return_list, dim)

######################################################################
# End copied code
######################################################################

# Will be using the ROI Solver Package
# Package had great documentation on setting objectives / constraints

if (!require("ROI")) install.packages("ROI"); library("ROI")
if (!require("ROI.plugin.glpk")) install.packages("ROI.plugin.glpk"); library("ROI.plugin.glpk")
if (!require("ROI.plugin.quadprog")) install.packages("ROI.plugin.quadprog"); library("ROI.plugin.quadprog")
if (!require("ROI.plugin.alabama")) install.packages("ROI.plugin.alabama"); library("ROI.plugin.alabama")

###########################
# Min Variance Objective
###########################
markowitz_objective <- function(r_mat) {
  objective <- Q_objective(Q = 2 * cov(r_mat), 
                           L = rep(0, NCOL(r_mat)))
  list(objective = objective)
}

###########################
# Min MAD Objective
###########################
mad_objective <- function(r_mat){
  x.names <- colnames(r_mat)
  N <- NCOL(r_mat)
  S <- nrow(r_mat)
  mu <- colMeans(r_mat)
  Amat <-  cbind(sweep(as.matrix(r_mat), 2,  mu), - diag(S), diag(S))
  var.names <- c(x.names, 
                 paste0("y_mad_aux", seq_len(S)),
                 paste0("z_mad_aux", seq_len(S)))
  
  constraint <-  L_constraint(L = Amat, dir = rep("==", S), 
                              rhs = rep(0, S), 
                              names = var.names)
  
  objective <- L_objective(L = c(rep(0, N), rep(1/S, 2 * S)))
  
  list(objective = objective, constraint = constraint)
}

#############################
# Min CVAR Objective
#############################

cvar_objective <- function(r_mat, alpha, probs = NULL) {
  x.names <- colnames(r_mat)
  N <- NCOL(r_mat)
  S <- NROW(r_mat)
  mu <- colMeans(r_mat)
  if (is.null(probs)) probs <- rep(1/S, S)
  if (alpha < 0.5) alpha <- 1 - alpha
  
  Amat <- cbind(as.matrix(r_mat),  diag(S), 1)
  var.names <- c(x.names, paste0("z_cvar_aux", seq_len(S)), "gamma")
  
  ## set bounds for gamma (-Inf, Inf) 
  bnds <- ROI::V_bound(li = c(N + S + 1), lb = c( -Inf),
                       ui = c(N + S + 1), ub = c(  Inf))
  
  constraint <- L_constraint(L = Amat, dir = rep(">=", S), 
                             rhs = rep(0, S), 
                             names = var.names)
  
  objective <- L_objective(c(rep(0, N), probs/(1 - alpha), 1))
  
  list(objective = objective, constraint = constraint, bounds = bnds)
}

############################
# Full Investment Constraint
############################
budget_constraint <- function(r_mat, dir = "==", rhs = 1) {
  x.names <- colnames(r_mat)
  L_constraint(L = rep(1, NCOL(r_mat)), 
               dir = dir,  rhs = rhs, names = x.names)
}

#############################
# Target Return Constraint
#############################
reward_constraint <- function(r_mat, dir = ">=", rhs = target) {
  x.names <- colnames(r_mat)
  L_constraint(L = colMeans(r_mat), dir = dir,  
               rhs = rhs, names = x.names)
}

#################################################
# Function for Computing MAD, Min Var, and CVAR
#################################################

compute_risk_measures <- function(returns, target) {
  
  ## Min Variance
  lp  <- OP(objective  =  markowitz_objective(returns)$objective,
            constraints = rbind(budget_constraint(returns),
                                reward_constraint(returns, rhs = target)))
  (sol <- ROI_solve(lp, solver = "quadprog"))
  min_var_solution <- round(solution(sol), 4)
  
  ## MAD
  lp  <- OP(objective  =  mad_objective(returns)$objective,
            constraints = rbind(mad_objective(returns)$constraint,
                                budget_constraint(returns),
                                reward_constraint(returns, rhs = target),
                                use.names = TRUE))
  (sol <- ROI_solve(lp, solver = "glpk"))
  mad_solution <- round(solution(sol)[seq_len(NCOL(returns))], 4)
  
  ## CVAR
  tmp <- cvar_objective(returns, alpha = 0.90)
  lp  <- OP(objective  =  tmp$objective,
            constraints = rbind(tmp$constraint,
                                budget_constraint(returns),
                                reward_constraint(returns, rhs = target),
                                use.names = TRUE),
            bounds = tmp$bounds)
  (sol <- ROI_solve(lp, solver = "glpk"))
  cvar_solution <- round(solution(sol)[seq_len(NCOL(returns))], 4)
  
  return(cbind(min_var_solution, mad_solution, cvar_solution))
}

#############################
# Compute Portfolio Weights
#############################

daily_multiplier <- 1/252
weekly_multiplier <- 5/252
monthly_multiplier <- 21/252
quarterly_multiplier <- 62/252
annual_multiplier <- 1

daily_2pct_target <- compute_risk_measures(return_list_df$days_1, (0.02 * daily_multiplier))
daily_4pct_target <- compute_risk_measures(return_list_df$days_1, (0.04 * daily_multiplier))
daily_6pct_target <- compute_risk_measures(return_list_df$days_1, (0.06 * daily_multiplier))

weekly_2pct_target <- compute_risk_measures(return_list_df$days_5, (0.02 * weekly_multiplier))
weekly_4pct_target <- compute_risk_measures(return_list_df$days_5, (0.04 * weekly_multiplier))
weekly_6pct_target <- compute_risk_measures(return_list_df$days_5, (0.06 * weekly_multiplier))

monthly_2pct_target <- compute_risk_measures(return_list_df$days_21, (0.02 * monthly_multiplier))
monthly_4pct_target <- compute_risk_measures(return_list_df$days_21, (0.04 * monthly_multiplier))
monthly_6pct_target <- compute_risk_measures(return_list_df$days_21, (0.06 * monthly_multiplier))

quarterly_2pct_target <- compute_risk_measures(return_list_df$days_62, (0.02 * quarterly_multiplier))
quarterly_4pct_target <- compute_risk_measures(return_list_df$days_62, (0.04 * quarterly_multiplier))
quarterly_6pct_target <- compute_risk_measures(return_list_df$days_62, (0.06 * quarterly_multiplier))

annual_2pct_target <- compute_risk_measures(return_list_df$days_252, (0.02 * annual_multiplier))
annual_4pct_target <- compute_risk_measures(return_list_df$days_252, (0.04 * annual_multiplier))
annual_6pct_target <- compute_risk_measures(return_list_df$days_252, (0.06 * annual_multiplier))

# Save cached variables
save(return_list, return_list_df, 
     daily_2pct_target, daily_4pct_target, daily_6pct_target,
     weekly_2pct_target, weekly_4pct_target, weekly_6pct_target,
     monthly_2pct_target, monthly_4pct_target, monthly_6pct_target,
     quarterly_2pct_target, quarterly_4pct_target, quarterly_6pct_target,
     annual_2pct_target, annual_4pct_target, annual_6pct_target, file = cached_file)

}

convert_to_df <- function(target_matrix) {
  df <- as.data.frame(target_matrix)
  colnames(df) <- c("Min Variance", "Min MAD", "Min CVaR")
  return(df)
}

target_list <- list(
  daily_2pct = daily_2pct_target,
  daily_4pct = daily_4pct_target,
  daily_6pct = daily_6pct_target,
  weekly_2pct = weekly_2pct_target,
  weekly_4pct = weekly_4pct_target,
  weekly_6pct = weekly_6pct_target,
  monthly_2pct = monthly_2pct_target,
  monthly_4pct = monthly_4pct_target,
  monthly_6pct = monthly_6pct_target,
  quarterly_2pct = quarterly_2pct_target,
  quarterly_4pct = quarterly_4pct_target,
  quarterly_6pct = quarterly_6pct_target,
  annual_2pct = annual_2pct_target,
  annual_4pct = annual_4pct_target,
  annual_6pct = annual_6pct_target
)

# Convert each portfolio to a data frame with uniform column names
portfolio_weight_list <- lapply(target_list, convert_to_df)

options(scipen = 999)

# For some reason I was getting errors when attempting to calculate CVaR in get_portfolio_statistics
# The safe_cvar_calc() function will ensure the calculation is performed correctly
safe_cvar_calc <- function(returns, var_value) {
  # Ensure var_value is numeric and not an array/matrix
  var_value <- as.numeric(var_value)
  
  # Subset returns below the negative VaR
  sub_returns <- returns[returns <= -var_value]
  
  # Calculate mean if subset is not empty
  if (length(sub_returns) > 0) {
    return(-mean(sub_returns))
  } else {
    return(NA)
  }
}

###################################
# Compute Portfolio Statistics
###################################

get_portfolio_statistics <- function(weights, returns) {
  min_var_weights <- matrix(weights[,1], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  mad_weights <- matrix(weights[,2], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  cvar_weights <- matrix(weights[,3], nrow = 1, ncol = length(daily_2pct_target[,1]), byrow = TRUE)
  
  min_var_returns <- min_var_weights %*% t(returns)
  mad_returns <- mad_weights %*% t(returns)
  cvar_returns <- cvar_weights %*% t(returns)
  
  min_var_returns <- as.vector(min_var_returns)
  mad_returns <- as.vector(mad_returns)
  cvar_returns <- as.vector(cvar_returns)
  
  min_var_mean <- mean(min_var_returns)
  mad_mean <- mean(mad_returns)
  cvar_mean <- mean(cvar_returns)
  
  min_var_sd <- sd(min_var_returns)
  mad_sd <- sd(mad_returns)
  cvar_sd <- sd(cvar_returns)
  
  min_var_mad <- MeanAbsoluteDeviation(min_var_returns)
  mad_mad <- MeanAbsoluteDeviation(mad_returns)
  cvar_mad <- MeanAbsoluteDeviation(cvar_returns)
  
  min_var_var <- quantile(min_var_returns, 0.10) * -1
  mad_var <- quantile(mad_returns, 0.10) * -1
  cvar_var <- quantile(cvar_returns, 0.10) * -1

  min_var_cvar <- safe_cvar_calc(min_var_returns, min_var_var)
  mad_cvar <- safe_cvar_calc(mad_returns, mad_var)
  cvar_cvar <- safe_cvar_calc(cvar_returns, cvar_var)
  
  stats_df = data.frame(
    "Min Variance" = c(min_var_mean, min_var_sd, min_var_mad, min_var_var, min_var_cvar) * 100,
    "Min MAD" = c(mad_mean, mad_sd, mad_mad, mad_var, mad_cvar) * 100,
    "Min CVaR" = c(cvar_mean, cvar_sd, cvar_mad, cvar_var, cvar_cvar) * 100
  )
  
  row.names(stats_df) <- c("Expected Return", "Standard Deviation", "Mean Absolute Deviation", "Value-at-Risk", "Conditional Value-at-Risk")
  return(stats_df)
}

portfolio_stats_list <- list(
  stats_2pct_daily = get_portfolio_statistics(daily_2pct_target, return_list$days_1),
  stats_4pct_daily = get_portfolio_statistics(daily_4pct_target, return_list$days_1),
  stats_6pct_daily = get_portfolio_statistics(daily_6pct_target, return_list$days_1),
  
  stats_2pct_weekly = get_portfolio_statistics(weekly_2pct_target, return_list$days_5),
  stats_4pct_weekly = get_portfolio_statistics(weekly_4pct_target, return_list$days_5),
  stats_6pct_weekly = get_portfolio_statistics(weekly_6pct_target, return_list$days_5),
  
  stats_2pct_monthly = get_portfolio_statistics(monthly_2pct_target, return_list$days_21),
  stats_4pct_monthly =  get_portfolio_statistics(monthly_4pct_target, return_list$days_21),
  stats_6pct_monthly = get_portfolio_statistics(monthly_6pct_target, return_list$days_21),
  
  stats_2pct_quarterly = get_portfolio_statistics(quarterly_2pct_target, return_list$days_62),
  stats_4pct_quarterly = get_portfolio_statistics(quarterly_4pct_target, return_list$days_62),
  stats_6pct_quarterly = get_portfolio_statistics(quarterly_6pct_target, return_list$days_62),
  
  stats_2pct_annual = get_portfolio_statistics(annual_2pct_target, return_list$days_252),
  stats_4pct_annual = get_portfolio_statistics(annual_4pct_target, return_list$days_252),
  stats_6pct_annual = get_portfolio_statistics(annual_6pct_target, return_list$days_252)
)
```
